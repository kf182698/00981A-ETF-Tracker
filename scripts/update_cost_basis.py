"""
Script to update or initialize the cost basis for ETF holdings.

This script reads a daily change table (generated by the ETF tracker) and a
previous cost basis CSV, then updates the cost basis for each stock.  Cost
basis is defined as the total market value invested in a particular stock.

The logic is as follows:

* If a stock is appearing in the portfolio for the first time (``首次買進``
  flag is ``True`` in the daily change table), its cost basis is set to
  ``今日收盤價 * 今日股數``.  This value is stored in the output cost
  basis CSV along with the number of shares held.

* If a stock already exists in the cost basis file and new shares are
  purchased (``買賣超股數`` > 0), the cost basis is increased by
  ``買賣超股數 * 今日收盤價`` and the total shares are increased by
  ``買賣超股數``.

* If a stock is sold (``買賣超股數`` < 0), the share count in the cost
  basis file is reduced accordingly.  The cost basis is not reduced in
  proportion to the number of shares sold.  This design choice keeps the
  cost basis fixed, which means realized profit/loss is not accounted for
  when shares are sold.  If you wish to adjust the cost basis when selling
  shares, you can modify the logic accordingly.

* Manual adjustments: For stocks already present in the cost basis file, you
  can manually override the cost basis values in the CSV before running
  this script.  The script will respect the manually entered cost basis
  values and only add new purchases on top of the existing amounts.

Example usage::

    python update_cost_basis.py \
        --change-table-path reports/change_table_2025-10-31.csv \
        --cost-basis-path cost_basis.csv \
        --output-path cost_basis_updated.csv

The output CSV will contain the updated cost basis and share counts for
each stock.  You can then rename or overwrite your existing cost basis
file with the updated one.

"""

import argparse
import re
from pathlib import Path

import pandas as pd


def _log_realized_gains(record: dict, log_path: Path) -> None:
    df = pd.DataFrame([record])
    header = not log_path.exists()
    # 確保資料夾存在
    log_path.parent.mkdir(parents=True, exist_ok=True)
    df.to_csv(log_path, mode="a", index=False, header=header, encoding="utf-8-sig")


def load_cost_basis(path: Path) -> pd.DataFrame:
    """Load an existing cost basis CSV or create an empty DataFrame if none exists.

    The returned DataFrame has at least the following columns:
    ``股票代號``, ``股票名稱``, ``股數``, ``成本市值``.

    Any other columns present in the input file will be preserved.

    Args:
        path: Path to the cost basis CSV.

    Returns:
        pd.DataFrame with cost basis records.
    """
    if path.exists():
        df = pd.read_csv(path, encoding="utf-8-sig", dtype=str)
        # Normalize column names (strip BOM and whitespace)
        df.columns = [str(c).replace("\ufeff", "").strip() for c in df.columns]
        # Ensure required columns exist
        if "股數" not in df.columns or "成本市值" not in df.columns:
            raise ValueError(f"Cost basis file {path} must have '股數' and '成本市值' columns")
        return df
    # If no file exists, create an empty DataFrame
    return pd.DataFrame(columns=["股票代號", "股票名稱", "股數", "成本市值"])


def update_cost_basis(cost_df: pd.DataFrame, change_df: pd.DataFrame, report_date: str, gains_log_path: Path) -> pd.DataFrame:
    """Update cost basis DataFrame using daily change information.

    Args:
        cost_df: Existing cost basis DataFrame.
        change_df: DataFrame of the daily change table.  Must contain
            ``股票代號``, ``股票名稱``, ``今日股數``, ``買賣超股數``, ``首次買進``, ``今日收盤價``.
        report_date: Date string of the change table.
        gains_log_path: Path to the realized gains log file.

    Returns:
        Updated DataFrame with new cost basis and share counts.
    """
    # Ensure numeric fields are proper types
    change_df["今日股數"] = pd.to_numeric(change_df["今日股數"], errors="coerce").fillna(0).astype(int)
    change_df["買賣超股數"] = pd.to_numeric(change_df["買賣超股數"], errors="coerce").fillna(0).astype(int)
    change_df["今日收盤價"] = pd.to_numeric(change_df["今日收盤價"], errors="coerce").fillna(0.0)

    # Ensure cost_df numeric columns
    if not cost_df.empty:
        cost_df["股數"] = pd.to_numeric(cost_df["股數"], errors="coerce").fillna(0).astype(int)
        cost_df["成本市值"] = pd.to_numeric(cost_df["成本市值"], errors="coerce").fillna(0.0)

    # Use index on 股票代號 for fast lookup
    cost_df = cost_df.set_index("股票代號", drop=False)

    for _, row in change_df.iterrows():
        code = str(row["股票代號"]).strip()
        name = str(row.get("股票名稱", "")).strip()
        first_buy = False
        # Normalize boolean flags (could be string True/False)
        val = row.get("首次買進")
        if isinstance(val, str):
            first_buy = val.lower() == "true"
        else:
            first_buy = bool(val)
        new_shares = int(row["買賣超股數"])
        price = float(row["今日收盤價"])
        total_today_shares = int(row["今日股數"])
        # Determine if the stock is already in cost_df
        if code not in cost_df.index:
            # First encounter: Only process if first_buy flag or any shares held
            if first_buy or total_today_shares > 0:
                cost_value = price * total_today_shares
                cost_df.loc[code] = {
                    "股票代號": code,
                    "股票名稱": name,
                    "股數": total_today_shares,
                    "成本市值": cost_value,
                }
            continue
        # Stock already exists; update name if necessary
        if name:
            cost_df.loc[code, "股票名稱"] = name
        # If new shares purchased (positive), add to cost basis
        if new_shares > 0:
            existing_value = float(cost_df.loc[code, "成本市值"])
            existing_shares = int(cost_df.loc[code, "股數"])
            updated_value = existing_value + new_shares * price
            updated_shares = existing_shares + new_shares
            cost_df.loc[code, "成本市值"] = updated_value
            cost_df.loc[code, "股數"] = updated_shares
        # If shares sold, apply moving average cost and log if fully cleared
        elif new_shares < 0:
            existing_shares = int(cost_df.loc[code, "股數"])
            existing_value = float(cost_df.loc[code, "成本市值"])
            
            sell_shares = abs(new_shares)
            actual_sell_shares = min(sell_shares, existing_shares)
            
            avg_unit_cost = (existing_value / existing_shares) if existing_shares > 0 else 0.0
            updated_shares = existing_shares - actual_sell_shares
            
            deducted_cost = actual_sell_shares * avg_unit_cost
            updated_value = max(0.0, existing_value - deducted_cost)
            
            cost_df.loc[code, "股數"] = updated_shares
            cost_df.loc[code, "成本市值"] = updated_value
            
            # Log realized gains if fully cleared
            if updated_shares == 0 and actual_sell_shares > 0:
                realized_profit = actual_sell_shares * (price - avg_unit_cost)
                total_original_cost = actual_sell_shares * avg_unit_cost
                roi = (realized_profit / total_original_cost) if total_original_cost > 0 else 0.0
                
                record = {
                    "日期": report_date,
                    "股票代號": code,
                    "股票名稱": name,
                    "賣出股數": actual_sell_shares,
                    "平均單位成本": round(avg_unit_cost, 4),
                    "賣出價格": price,
                    "總投資成本": round(total_original_cost, 2),
                    "實現損益": round(realized_profit, 2),
                    "報酬率": round(roi, 4)
                }
                _log_realized_gains(record, gains_log_path)
    return cost_df.reset_index(drop=True)


def main() -> None:
    parser = argparse.ArgumentParser(description="Update or initialize cost basis for ETF holdings.")
    parser.add_argument(
        "--change-table-path",
        type=Path,
        required=True,
        help="Path to the daily change table CSV (reports/change_table_YYYY-MM-DD.csv)",
    )
    parser.add_argument(
        "--cost-basis-path",
        type=Path,
        default=Path("cost_basis.csv"),
        help="Path to the existing cost basis CSV (will be created if it does not exist)",
    )
    parser.add_argument(
        "--output-path",
        type=Path,
        default=Path("cost_basis_updated.csv"),
        help="Path to save the updated cost basis CSV",
    )
    parser.add_argument(
        "--gains-log-path",
        type=Path,
        default=Path("data/realized_gains_log.csv"),
        help="Path to save the realized gains log CSV",
    )
    args = parser.parse_args()

    # Extract date from change_table_path
    match = re.search(r"\d{4}-\d{2}-\d{2}", args.change_table_path.name)
    report_date = match.group(0) if match else pd.Timestamp.today().strftime("%Y-%m-%d")

    # Read daily change table
    change_df = pd.read_csv(args.change_table_path, encoding="utf-8-sig", dtype=str)
    change_df.columns = [str(c).replace("\ufeff", "").strip() for c in change_df.columns]
    # Verify required columns exist
    required_cols = ["股票代號", "今日股數", "買賣超股數", "首次買進", "股票名稱", "今日收盤價"]
    for col in required_cols:
        if col not in change_df.columns:
            raise ValueError(f"Column {col} missing from change table {args.change_table_path}")
    # Load existing cost basis
    cost_df = load_cost_basis(args.cost_basis_path)
    # Update cost basis
    updated_df = update_cost_basis(cost_df, change_df, report_date, args.gains_log_path)
    # Save output
    updated_df.to_csv(args.output_path, index=False, encoding="utf-8-sig")
    print(f"Updated cost basis written to {args.output_path}")


if __name__ == "__main__":
    main()